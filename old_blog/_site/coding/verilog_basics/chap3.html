<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Aaron's Wiki by </title>

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <meta name="viewport" content="width=device-width">
    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Aaron's Wiki</h1>
        <!-- <p>Hello, thanks for visiting my personal wiki.</p> -->
        <!-- <h2>Projects</h2> -->
        <p class="view"><a href="blog/index">main page</a></p>
        <p class="view"><a href="blog/projects/projects_sum.html">Projects</a></p>
        <p class="view"><a href="blog/papers/papers_index.html">Paper Reviews</a></p>
        <p class="view"><a href="blog/books/books_index.html">Book Reviews</a></p>
        <p class="view"><a href="blog/coding/coding_index.html">Coding and APIs</a></p>
        <p class="view"><a href="blog/posts/posts_index.html">Posts</a></p>
        <!-- <p class="view"><a href="/index">main page</a></p>
        <p class="view"><a href="/projects/projects_sum.html">Projects</a></p>
        <p class="view"><a href="/papers/papers_index.html">Paper Reviews</a></p>
        <p class="view"><a href="/books/books_index.html">Book Reviews</a></p>
        <p class="view"><a href="/coding/coding_index.html">Coding and APIs</a></p>
        <p class="view"><a href="/posts/posts_index.html">Posts</a></p> -->
        <!-- <p class="view"><a href="/blog/papers/nn_models/model_summary.html">Papers</a></p> -->
        <!-- <h2>Book and Code Reviews</h2> -->
        <!-- <p class="view"><a href="">Books</a></p>
        <p class="view"><a href="">Python</a></p>
        <p class="view"><a href="">C++</a></p> -->
        <!-- <h2>Contacts</h2> -->
        

        

        
      </header>
      <section>

      <h1 id="chapter-3-fifos">Chapter 3: FIFOs</h1>
<h2 id="synchronous-fifos">Synchronous FIFOs</h2>
<p>There are two ways of writing a synchronous FIFO:</p>
<ol>
  <li>Use a counter for the number of elements. The disadvantage is obvious, you need an extra counter and this affects area and speed.</li>
  <li>Use one more bit on both write and reader cnt.</li>
</ol>

<pre><code class="language-Verilog">module syn_fifo(
  data_in,
  data_out,
  clk,
  rst,
  rd,
  wr,
  full,
  empty
  );
  parameter DATA_WIDTH = 8;
  parameter ADDR_WIDTH = 8;
  parameter RAM_DEPTH = (1 &lt;&lt; ADDR_WIDTH);

  input [DATA_WIDTH-1:0] data_in;
  input clk, rst, rd, wr;

  output [DATA_WIDTH-1:0] data_out;
  output full, empty;

  reg [ADDR_WIDTH-1:0] wr_pointer, rd_pointer;
  reg [ADDR_WIDTH-1:0] status_cnt;
  reg [DATA_WIDTH-1:0] data_out;

  wire [DATA_WIDTH-1:0] data_ram;

  assign full = (status_cnt == (RAM_DEPTH-1));
  assign empty = (status_cnt == 0);

  always @ (posedge clk or posedge rst)
  begin: WRITE_POITER
    if (rst) begin
      wr_pointer &lt;= 0;
    end
    else begin
      if (wr_en) begin
        wr_pointer &lt;= wr_pointer + 1;
      end
    end
  end

  always @ (posedge clk or posedge rst)
  begin: READ_POINTER
    if (rst) begin
       rd_pointer &lt;= 0;
    end
    else begin
      if (rd_en) begin
        rd_pointer &lt;= rd_pointer + 1;
      end
    end
  end

  // method 1
  always @ (posedge clk or posedge rst)
  begin: STATUS_COUNTER
    if (rst) begin
    end
    else begin
      if (rd_en &amp;&amp; !wr_en &amp;&amp; status_cnt != 0) begin
        status_cnt &lt;= status_cnt - 1;
      end
      if (wr_en &amp;&amp; !rd_en &amp;&amp; status_cnt != RAM_DEPTH) begin
        status_cnt &lt;= status_cnt + 1;
      end
    end
  end

  ram_dp_ar_aw #(DATA_WIDTH, ADDR_WIDTH)DP_RAM(
    .address_0(wr_pointer),
    .data_0(data_in),
    .cs_0(1'b1),
    .we_0(wr_en),
    .oe_0(1'b0),
    .address_1(rd_pointer),
    .data_1(data_ram),
    .cs_1(1'b1),
    .we_1(1'b0),
    .oe_1(rd_en)
    );

endmodule
</code></pre>

<pre><code class="language-Verilog">module syn_fifo(
  data_in,
  data_out,
  clk,
  rst,
  rd,
  wr,
  full,
  empty
  );
  parameter DATA_WIDTH = 8;
  parameter ADDR_WIDTH = 8;
  parameter RAM_DEPTH = (1 &lt;&lt; ADDR_WIDTH);

  input [DATA_WIDTH-1:0] data_in;
  input clk, rst, rd, wr;

  output [DATA_WIDTH-1:0] data_out;
  output full, empty;

  reg [ADDR_WIDTH:0] wr_pointer, rd_pointer;
  reg [DATA_WIDTH-1:0] data_out;

  wire [DATA_WIDTH-1:0] data_ram;
  wire matched;

  assign matched = (wr_pointer[ADDR_WIDTH-1:0] == rd_pointer[ADDR_WIDTH-1:0]);

  assign full = matched &amp;&amp; (wr_pointer ^ rd_pointer);
  assign empty = matched &amp;&amp; (wr_pointer == rd_pointer);
   ....
</code></pre>

<h2 id="asynchronous-fifos">Asynchronous FIFOs</h2>
<p>Asynchronous FIFO has two clock sources:</p>
<ol>
  <li>Cross clock domain signal passing: this might causes <strong>metastability</strong> (signal that do not assume a stable 0 or 1, potentially because of sampling from the edge of a signal).</li>
  <li><strong>two flip flop synchroniser</strong> solves metastability.</li>
  <li>Gray code counter allows one bit to change at a time, minimizing the number of glitches.</li>
</ol>

<pre><code class="language-Verilog">module async_FIFO(
  W_clk,
  data_in,
  w_enable,
  R_clk,
  data_out,
  r_enable,
  async_reset,
  full,
  empty
  );
parameter DATA_WIDTH = 8;
parameter ADDR_WIDTH = 4;
parameter MEM_DEPTH = (1&lt;&lt;ADDR_WIDTH);

input W_clk, R_clk, async_reset;
input [DATA_WIDTH-1:0] data_in;
input w_enable, r_enable;

output reg [DATA_WIDTH-1:0] data_out;
output reg full, empty;

reg [DATA_WIDTH-1:0] MEM[MEM_DEPTH-1:0];
reg [ADDR_WIDTH-1:0] pNextWordToRead, pNextWordToWrite;
reg [ADDR_WIDTH-1:0] read_count, write_count;

wire going_full, going_empty;
reg preset_full, preset_empty;

// dual port memory
always @ ( posedge R_clk ) begin
  if ( r_enable &amp;&amp; !empty)
    data_out &lt;= MEM[pNextWordToRead];
end

always @ (posedge W_clk) begin
  if (w_enable &amp;&amp; !full)
    MEM[pNextWordToWrite] &lt;= data_in;
end

initial begin
  pNextWordToWrite &lt;= 4'b0;
  write_count &lt;= 1;
  pNextWordToRead &lt;= 4'b0;
  read_count &lt;= 1;
end

// construct read write pointers
always @(posedge R_clk) begin
  if (async_reset) begin
    pNextWordToRead &lt;= 4'b0;
    read_count &lt;= 1;
  end
  else begin
    if (r_enable &amp;&amp; !empty) begin
      read_count &lt;= read_count + 1;
      pNextWordToRead &lt;= {read_count[ADDR_WIDTH-1],
                          read_count[ADDR_WIDTH-2:0] ^ read_count[ADDR_WIDTH-1:1]};
    end
  end
end


// gray code counter
always @(posedge W_clk) begin
  if (async_reset) begin
    pNextWordToWrite &lt;= 4'b0;
    pNextWordToRead &lt;= 4'b0;
    write_count &lt;= 1;
    read_count &lt;= 1;
  end
  else begin
    if (w_enable &amp;&amp; !full) begin
      write_count &lt;= write_count + 1;
      pNextWordToWrite &lt;= {write_count[ADDR_WIDTH-1],
                          write_count[ADDR_WIDTH-2:0] ^ write_count[ADDR_WIDTH-1:1]};
    end
    if (r_enable &amp;&amp; !empty) begin
      read_count &lt;= read_count + 1;
      pNextWordToRead &lt;= {read_count[ADDR_WIDTH-1],
                          read_count[ADDR_WIDTH-2:0] ^ read_count[ADDR_WIDTH-1:1]};
    end
  end
end

// construct full empty logic
assign going_empty = (pNextWordToWrite[ADDR_WIDTH-2] ~^ pNextWordToRead[ADDR_WIDTH-1]) &amp;
                     (pNextWordToWrite[ADDR_WIDTH-1] ^  pNextWordToRead[ADDR_WIDTH-2]);

assign going_full = (pNextWordToWrite[ADDR_WIDTH-2] ^  pNextWordToRead[ADDR_WIDTH-1]) &amp;
                     (pNextWordToWrite[ADDR_WIDTH-1] ~^ pNextWordToRead[ADDR_WIDTH-2]);

 // a pre full/empty signal
always @ (*) begin
  if (pNextWordToRead == pNextWordToWrite) begin
    if (going_full == 1) begin
      preset_full &lt;= 1;
    end
    if (going_empty == 1) begin
      preset_empty &lt;= 1;
    end
  end
end

// set full and empty under different clock
initial begin
  full &lt;= 0;
  empty &lt;= 0;
end
always @ (posedge W_clk or posedge preset_full) begin
  if (preset_full == 1) begin
    full &lt;= 1;
  end
  else begin
    full &lt;= 0;
  end
end

always @ (posedge R_clk or posedge preset_empty) begin
  if (preset_empty == 1) begin
    empty &lt;= 1;
  end
  else begin
    empty &lt;= 0;
  end
end

endmodule
</code></pre>


      </section>
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>


  
  </body>
</html>
