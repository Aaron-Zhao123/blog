<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Aaron's Wiki by </title>

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <meta name="viewport" content="width=device-width">
    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js'></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Aaron's Wiki</h1>
        <!-- <p>Hello, thanks for visiting my personal wiki.</p> -->
        <!-- <h2>Projects</h2> -->
        <p class="view"><a href="blog/index">main page</a></p>
        <p class="view"><a href="blog/projects/projects_sum.html">Projects</a></p>
        <p class="view"><a href="blog/papers/papers_index.html">Paper Reviews</a></p>
        <p class="view"><a href="blog/books/books_index.html">Book Reviews</a></p>
        <p class="view"><a href="blog/coding/coding_index.html">Coding and APIs</a></p>
        <p class="view"><a href="blog/posts/posts_index.html">Posts</a></p>
        <!-- <p class="view"><a href="/index">main page</a></p>
        <p class="view"><a href="/projects/projects_sum.html">Projects</a></p>
        <p class="view"><a href="/papers/papers_index.html">Paper Reviews</a></p>
        <p class="view"><a href="/books/books_index.html">Book Reviews</a></p>
        <p class="view"><a href="/coding/coding_index.html">Coding and APIs</a></p>
        <p class="view"><a href="/posts/posts_index.html">Posts</a></p> -->
        <!-- <p class="view"><a href="/blog/papers/nn_models/model_summary.html">Papers</a></p> -->
        <!-- <h2>Book and Code Reviews</h2> -->
        <!-- <p class="view"><a href="">Books</a></p>
        <p class="view"><a href="">Python</a></p>
        <p class="view"><a href="">C++</a></p> -->
        <!-- <h2>Contacts</h2> -->
        

        

        
      </header>
      <section>

      <h1 id="chapter-1-data-structure">Chapter 1: Data structure</h1>

<h2 id="dequeue">Dequeue</h2>
<pre><code class="language-Python">from collections import deque


def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)
    for line in lines:
        if pattern in line:
            yield line, previous_lines
        previous_lines.append(line)

# Example use on a file
if __name__ == '__main__':
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)
</code></pre>

<p><strong>yield</strong> is a generator object, the function is executed until the for loop executes.
<strong>dequeue</strong> creates a fixed-size queue old elements are deleted automatically.
The complexity of insert and delete in a queue is O(1), but O(N) for arrays.</p>

<h2 id="heapq">Heapq</h2>
<p>Heap queue algorithm, also known as the priority queue algorithm.
Heaps are binary trees for which every parent node has a value less than or equal to any of its children.
This implementation uses arrays for which heap[k] &lt;= heap[2<em>k+1] and heap[k] &lt;= heap[2</em>k+2] for all k, counting elements from zero.
For the sake of comparison, non-existing elements are considered to be infinite.
The interesting property of a heap is that its smallest element is always the root, heap[0]</p>

<p>The feature of heapq is that heap[0] always has the <strong>smallest</strong> value.</p>

<p><strong>nlargest()</strong> and <strong>nsmallest()</strong> are fast if list is large,
<strong>sorted(items)[:N]</strong> is faster if N is large.
<strong>min</strong>, <strong>max</strong> if fast for single element</p>

<pre><code class="language-Python">import heapq
nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
</code></pre>

<p>Example: Priority queue</p>
<pre><code class="language-Python">import heapq

class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>

<h2 id="multidict">MultiDict</h2>
<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'a'</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="p">[</span><span class="s">'b'</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre>
</div>
<p>This will create the following:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
}
e = {
    'a' : {1, 2, 3},
    'b' : {4, 5}
}
</code></pre>
</div>

<h2 id="ordereddict">OrderedDict</h2>
<pre><code class="language-Python">rom collections import OrderedDict

d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4
# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
    print(key, d[key])
</code></pre>
<p>Thie maintains the order that keys are created, when the existing is inserted,
the order won’t be changed.
This means <strong>OrderedDict</strong> uses twice the memory.</p>

<h2 id="operate-on-dict-with-lambda">Operate on Dict with lambda</h2>
<pre><code class="language-Python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
min(prices, key=lambda k: prices[k]) # Returns 'FB'
</code></pre>

<h2 id="slicing">Slicing</h2>
<pre><code class="language-Python">&gt;&gt;&gt; a = slice(5, 50, 2)
&gt;&gt;&gt; a.start
5
&gt;&gt;&gt; a.stop
50
&gt;&gt;&gt; a.step
2
&gt;&gt;&gt;
</code></pre>

<h2 id="counter">Counter</h2>
<pre><code class="language-Python">words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', "you're", 'under'
]
from collections import Counter
word_counts = Counter(words)
# 出现频率最高的3个单词
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</code></pre>

<h2 id="itemgetter-with-dict">itemgetter with dict</h2>
<pre><code class="language-Python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))

rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
</code></pre>
<p>The code above shows how <code class="highlighter-rouge">itemgetter</code> returns a callable object. Apparently, this can be replaced by <code class="highlighter-rouge">lambda</code> functions.</p>
<pre><code class="language-Python">rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
</code></pre>

<h2 id="sorting-in-a-class">Sorting in a class</h2>
<pre><code class="language-Python">class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)


def sort_notcompare():
    users = [User(23), User(3), User(99)]
    sorted(users, key=lambda u: u.user_id)

    # Or use attrgetter()
    from operator import attrgetter
    sorted(users, key=attrgetter('user_id'))
</code></pre>

<p>Notice <code class="highlighter-rouge">users</code> cannot be sorted directly, this case, we can whether use again an lambda function or the attrgetter.</p>

<h2 id="groupby">groupby</h2>
<pre><code class="language-Python">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))
# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre>
<p>Firstly sort the list using <code class="highlighter-rouge">itemgetter</code>, it then shows how to use group by, each group is produced by date.</p>

<h2 id="filtering">Filtering</h2>
<p>Use generator and iterator, <strong>filter</strong> creates an iterator and convert it using <strong>list</strong></p>
<pre><code class="language-Python">values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False
ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
</code></pre>

<p><strong>itertools.compress()</strong></p>
<pre><code class="language-Python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
from itertools import compress
more5 = [n &gt; 5 for n in counts]
list(compress(addresses, more5))
# ['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
</code></pre>

<p><strong>namedtuple()</strong></p>
<pre><code class="language-Python">from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total
</code></pre>
<p>Better naming than hard coded numbers.</p>

<pre><code class="language-Python">from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])

# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)

# Function to convert a dictionary to a Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)
</code></pre>
<p>Using the above code, stock can be updated by passing a dictionary into the function <strong>dict_to_stock</strong>, this <strong>**s</strong> is a useful way of extracting components in a dict.</p>

<h2 id="combining-multiple-dicts">Combining multiple dicts</h2>
<p>One method is to use <strong>ChainMap</strong></p>
<pre><code class="language-Python">from collections import ChainMap
c = ChainMap(a,b)
</code></pre>
<p>Chainmap creates a list to collect all of these dictionaries, but not creating a new dictionaries, all the old dictionaries stay valid, any updates of the original dictionaries propagates to the new dictionary.</p>

<p><strong>update</strong> is another method of merging dictionaries</p>
<pre><code class="language-Python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = dict(b)
merged.update(a)
</code></pre>
<p>merged creates a completely different dictionary, updates on old dictionaries will not affect the newly created one.</p>


      </section>
      <footer>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>


  
  </body>
</html>
